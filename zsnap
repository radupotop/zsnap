#!/usr/bin/env python3

import argparse
import os
import re
import shlex
import shutil
import subprocess
import sys
from datetime import date, timedelta
from typing import List, Optional


DATASETS = [
    "tank/backup",
    "tank/packages",
]

RETENTION_DAYS = 182
SNAP_NAME_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")


def log(message: str) -> None:
    print(message)


def run_cmd(cmd: List[str], *, dry_run: bool, capture: bool = False) -> subprocess.CompletedProcess:
    if dry_run and len(cmd) >= 2 and cmd[0] == "zfs" and cmd[1] in {"snapshot", "destroy"}:
        log(f"DRY_RUN: {shlex.join(cmd)}")
        return subprocess.CompletedProcess(cmd, 0, stdout="")

    return subprocess.run(
        cmd,
        check=True,
        text=True,
        stdout=subprocess.PIPE if capture else None,
        stderr=subprocess.PIPE if capture else None,
    )


def exists(name: str) -> bool:
    result = subprocess.run(
        ["zfs", "list", "-H", "-o", "name", name],
        check=False,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return result.returncode == 0


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create daily ZFS snapshots and prune old snapshots by month."
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print zfs snapshot/destroy commands without executing them.",
    )
    return parser.parse_args()


def cleanup_snapshots(dataset: str, cutoff_date: date, dry_run: bool) -> None:
    # 1. Read snapshots for this dataset only.
    snapshot_names = run_cmd(
        ["zfs", "list", "-H", "-o", "name", "-t", "snapshot", dataset],
        dry_run=dry_run,
        capture=True,
    ).stdout.splitlines()

    # 2. Parse as tuples: (date, snapshot_name)
    parsed: List[tuple] = []
    for snap in snapshot_names:
        base, sep, snap_name = snap.partition("@")
        if sep != "@":
            continue

        # Safety: operate only on snapshots for this exact dataset.
        if base != dataset:
            continue

        # Safety: only touch YYYY-MM-DD snapshots.
        if not SNAP_NAME_RE.fullmatch(snap_name):
            continue

        try:
            snap_date = date.fromisoformat(snap_name)
        except ValueError:
            continue
        parsed.append((snap_date, snap))

    # 3. Select snapshots older than now() - RETENTION_DAYS.
    selected = sorted(
        [(snap_date, snap) for snap_date, snap in parsed if snap_date < cutoff_date],
        key=lambda item: item[0],
    )

    # 4. Print selected snapshots and destroy them.
    if not selected:
        log(f"No old snapshots to delete for dataset: {dataset}")
        return

    log(f"Snapshots selected for deletion in dataset {dataset}:")
    for snap_date, snap in selected:
        log(f"  {snap_date.isoformat()}  {snap}")
    for _, snap in selected:
        log(f"Deleting old snapshot: {snap}")
        run_cmd(["zfs", "destroy", snap], dry_run=dry_run)


def main() -> int:
    if not shutil_which("zfs"):
        print("Missing required command: zfs", file=sys.stderr)
        return 1

    args = parse_args()
    dry_run = args.dry_run or os.environ.get("DRY_RUN") == "1"
    now = date.today()
    today = now.isoformat()
    cutoff_date = now - timedelta(days=RETENTION_DAYS)

    log(f"Snapshot suffix: @{today}")
    log(f"Deleting snapshots older than date: {cutoff_date.isoformat()}")

    for dataset in DATASETS:
        if not exists(dataset):
            log(f"Skipping missing dataset: {dataset}")
            continue

        snap = f"{dataset}@{today}"
        if exists(snap):
            log(f"Snapshot already exists, skipping: {snap}")
            continue

        log(f"Creating snapshot: {snap}")
        run_cmd(["zfs", "snapshot", snap], dry_run=dry_run)

    for dataset in DATASETS:
        if not exists(dataset):
            continue
        cleanup_snapshots(dataset, cutoff_date, dry_run)

    return 0


def shutil_which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


if __name__ == "__main__":
    raise SystemExit(main())
